{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Signed Heat Method","text":"<p><code>signed-heat-3d</code> is a C++ library implementing the Signed Heat Method for computing robust signed distance fields (SDFs) to triangle meshes, polygon meshes, and point clouds in 3D. </p> <p></p> <p>Python bindings to this C++ code also exist via the <code>signed_heat_method</code> package on PyPI: toggle the \u201cC++/Python\u201d switch at the top of this page to see documentation for the Python version.</p> <p>Sample:</p> <p>The library uses geometry-central to manage mesh and point cloud structures. <pre><code>#include \"signedheat3d/signed_heat_grid_solver.h\"\n#include \"signedheat3d/signed_heat_tet_solver.h\"\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\n#include \"geometrycentral/pointcloud/point_position_normal_geometry.h\"\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\nusing namespace geometrycentral::pointcloud;\n// Assume we have some input geometry -- these are geometry-central objects.\nSurfaceMesh mesh;\nVertexPositionGeometry geometry;\nPointPositionNormalGeometry pointGeom;\n// Initalize tet mesh solver\nSignedHeatTetSolver tetSolver = SignedHeatTetSolver();\n// Configure some options\nSignedHeat3DOptions solveOptions; // all the default options should be pretty good\n// Solve!\nVector&lt;double&gt; sdf = tetSolver.computeDistance(geometry, solveOptions); // get distance to the mesh!\nVector&lt;double&gt; sdf = tetSolver.computeDistance(pointGeom, solveOptions); // get distance to the point cloud!\n// Solve on a grid instead.\nSignedHeatGridSolver gridSolver = SignedHeatGridSolver();\nsolveOptions.resolution = {64, 64, 64}; // change the resolution of the grid\nVector&lt;double&gt; sdf = gridSolver.computeDistance(geometry, solveOptions); // get distance to the mesh!\nVector&lt;double&gt; sdf = gridSolver.computeDistance(pointGeom, solveOptions); // get distance to the point cloud!\n</code></pre></p> <p>See the sample project to get started with a GUI and build system.</p> <p>More info about the method, including a blog-style summary, an introductory 10-minute talk, and the corresponding academic paper are all located at the project page here.</p> <p>Related libraries</p> <p>The Signed Heat Method has been implemented in both C++ and Python, in 2D and in 3D.</p> <ul> <li>If you\u2019re interested in using the Signed Heat Method on 2D surface domains, rather than in 3D space, the method has been implemented in geometry-central for triangle mesh domains, polygon mesh domains, and point cloud domains. A demo project exists at signed-heat-demo.</li> <li>Likewise, Python bindings to the geometry-central C++ code has been implemented in the Python package potpourri3d.</li> </ul> <p>Credits</p> <p>If this code contributes to an academic publication, cite it as: <pre><code>@article{Feng:2024:SHM,\nauthor = {Feng, Nicole and Crane, Keenan},\ntitle = {A Heat Method for Generalized Signed Distance},\nyear = {2024},\nissue_date = {August 2024},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nvolume = {43},\nnumber = {4},\nissn = {0730-0301},\nurl = {https://doi.org/10.1145/3658220},\ndoi = {10.1145/3658220},\njournal = {ACM Trans. Graph.},\nmonth = {jul},\narticleno = {92},\nnumpages = {16}\n}\n</code></pre></p>"},{"location":"algorithm/solvers/","title":"Solvers","text":"<p>There are two solvers: <code>SignedHeatTetSolver</code> solves for SDFs on a tetrahedralized domain, and  <code>SignedHeatGridSolver</code> solves for SDFs on gridded domain. Both solvers assume the domain is rectangular, though future releases may consider arbitrary domains.</p> <code>SignedHeatTetSolver()</code> <p>Construct an SDF solver that acts on a tet-meshed domain.</p> <ul> <li>The solver has a member variable called <code>VERBOSE</code>, that if <code>true</code>, prints status updates during solves.</li> </ul> <code>SignedHeatGridSolver()</code> <p>Construct an SDF solver that acts on a gridded domain.</p> <ul> <li>The solver has a member variable called <code>VERBOSE</code>, that if <code>true</code>, prints status updates during solves.</li> </ul> <p>To improve performance, operators and spatial discretizations are only built as necessary, and re-used in future computations if the underlying discretization hasn\u2019t changed. This means future computations can be significantly faster than the initial solve (which includes, for example, tet mesh construction and matrix factorization.)</p>"},{"location":"algorithm/solvers/#signed-distance-to-triangle-and-polygon-meshes","title":"Signed distance to triangle and polygon meshes","text":"<p>Example:</p> <p>The library uses geometry-central to manage mesh and point cloud structures. <pre><code>#include \"signedheat3d/signed_heat_grid_solver.h\"\n#include \"signedheat3d/signed_heat_tet_solver.h\"\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\n// Assume we have some input geometry -- these are geometry-central objects.\nSurfaceMesh mesh;\nVertexPositionGeometry geometry;\n// Initalize tet mesh solver\nSignedHeatTetSolver tetSolver = SignedHeatTetSolver();\n// Configure some options\nSignedHeat3DOptions solveOptions; // all the default options should be pretty good\n// Solve!\nVector&lt;double&gt; sdf = tetSolver.computeDistance(geometry, solveOptions); // get distance to the mesh!\n// Solve on a grid instead.\nSignedHeatGridSolver gridSolver = SignedHeatGridSolver();\nsolveOptions.resolution = {64, 64, 64}; // change the resolution of the grid\nVector&lt;double&gt; sdf = gridSolver.computeDistance(geometry, solveOptions); // get distance to the mesh!\n</code></pre></p> <code>Vector&lt;double&gt; SignedHeatTetSolver::computeDistance(VertexPositionGeometry&amp; geometry, const SignedHeat3DOptions&amp; options = SignedHeat3DOptions())</code> <p>Solve for an SDF on a tet mesh, to the mesh represented by <code>geometry</code>. Returns a <code>Vector&lt;double&gt;</code> object, which is a <code>geometry-central</code> object typedef\u2019ed to Eigen\u2019s vector type <code>Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</code>.</p> <ul> <li><code>geometry</code> is a geometry-central VertexPositionGeometry, which represents the geometry of a given mesh.</li> <li><code>options</code> is a struct containing solve options (see below).</li> </ul> <code>Vector&lt;double&gt; SignedHeatGridSolver::computeDistance(VertexPositionGeometry&amp; geometry, const SignedHeat3DOptions&amp; options = SignedHeat3DOptions())</code> <p>Solve for an SDF on a grid, to the mesh represented by <code>geometry</code>. Returns a <code>Vector&lt;double&gt;</code> object, which is a <code>geometry-central</code> object typedef\u2019ed to Eigen\u2019s vector type <code>Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</code>.</p> <ul> <li><code>geometry</code> is a geometry-central VertexPositionGeometry, which represents the geometry of a given mesh.</li> <li><code>options</code> is a struct containing solve options (see below).</li> </ul>"},{"location":"algorithm/solvers/#signed-distance-to-point-clouds","title":"Signed distance to point clouds","text":"<p>Example: <pre><code>#include \"signedheat3d/signed_heat_grid_solver.h\"\n#include \"signedheat3d/signed_heat_tet_solver.h\"\n#include \"geometrycentral/pointcloud/point_position_normal_geometry.h\"\nusing namespace geometrycentral::pointcloud;\n// Assume we have some input geometry -- these are geometry-central objects.\nPointPositionNormalGeometry pointGeom;\n// Initalize tet mesh solver\nSignedHeatTetSolver tetSolver = SignedHeatTetSolver();\n// Configure some options\nSignedHeat3DOptions solveOptions; // all the default options should be pretty good\n// Solve!\nVector&lt;double&gt; sdf = tetSolver.computeDistance(pointGeom, solveOptions); // get distance to the point cloud!\n// Solve on a grid instead.\nSignedHeatGridSolver gridSolver = SignedHeatGridSolver();\nsolveOptions.resolution = {64, 64, 64}; // change the resolution of the grid\nVector&lt;double&gt; sdf = gridSolver.computeDistance(pointGeom, solveOptions); // get distance to the point cloud!\n</code></pre></p> <code>Vector&lt;double&gt; SignedHeatTetSolver::computeDistance(PointPositionNormalGeometry&amp; pointGeom, const SignedHeat3DOptions&amp; options = SignedHeat3DOptions())</code> <p>Solve for an SDF on a tet mesh, to the given point cloud with normals. Returns a <code>Vector&lt;double&gt;</code> object, which is a <code>geometry-central</code> object typedef\u2019ed to Eigen\u2019s vector type <code>Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</code>.</p> <ul> <li><code>pointGeom</code> is a geometry-central PointPositionNormalGeometry, which represents a point cloud with normals.</li> <li><code>options</code> is a struct containing solve options (see below).</li> </ul> <code>Vector&lt;double&gt; SignedHeatGridSolver::computeDistance(PointPositionNormalGeometry&amp; pointGeom, const SignedHeat3DOptions&amp; options = SignedHeat3DOptions())</code> <p>Solve for an SDF on a grid, to the given point cloud with normals. Returns a <code>Vector&lt;double&gt;</code> object, which is a <code>geometry-central</code> object typedef\u2019ed to Eigen\u2019s vector type <code>Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</code>.</p> <ul> <li><code>pointGeom</code> is a geometry-central PointPositionNormalGeometry, which represents a point cloud with normals.</li> <li><code>options</code> is a struct containing solve options (see below).</li> </ul>"},{"location":"algorithm/solvers/#solve-options","title":"Solve options","text":"<p>All <code>computeDistance()</code> functions take an optional argument called <code>options</code>, which is a struct with the following variables:</p> Field Default value Meaning <code>levelSetConstraint</code> <code>LevelSetConstraint::ZeroSet</code> Whether to apply level set constraints, with options <code>LevelSetConstraint::ZeroSet</code>, <code>LevelSetConstraint::None</code>, <code>LevelSetConstraint::Multiple</code>, corresponding to preservation of the input surface as the zero set, as multiple level sets (one for each surface component), or no constraints, respectively. <code>tCoef</code> <code>1</code> Sets the time used for short-time heat flow. Generally you don\u2019t have to change this. <code>bboxMin</code> The 3D position of the minimum corner of the computational domain, which is assumed to be an axis-aligned rectangular prism. If not specified, the size of the domain will be automatically computed so as to encompass the input source geometry. <code>bboxMax</code> The 3D position of the maximum corner of the computational domain. <code>resolution</code> <code>np.array([2**5, 2**5, 2**5])</code> 3D vector specifying the tet or grid spacing, with larger values indicating more refinement. If solving on a grid, this corresponds to the number of nodes along each dimension. Default values are 2^{5}. <code>rebuild</code> <code>True</code> If <code>True</code>, force (re)build the underlying tet mesh or grid domain. This will induce the solver to re-factorize the matrices involved in the solve."},{"location":"algorithm/solvers/#helper-functions","title":"Helper functions","text":""},{"location":"algorithm/solvers/#tet-mesh-solver","title":"Tet mesh solver","text":"<code>Eigen::MatrixXd SignedHeatTetSolver::getVertices() const</code> <p>Returns a dense <code>n_vertices</code> x 3 matrix representing the vertex locations of the underlying tet mesh domain.</p> <code>SignedHeatTetSolver::getTets() const</code> <p>Returns a dense integer-valued <code>n_tets</code> x 4 matrix representing the tetrahedra of the underlying tet mesh domain, where each tetrahedra is given by four vertex indices (0-indexed).</p> <code>void SignedHeatTetSolver::isosurface(std::unique_ptr&lt;SurfaceMesh&gt;&amp; isoMesh, std::unique_ptr&lt;VertexPositionGeometry&gt;&amp; isoGeom, const Vector&lt;double&gt;&amp; phi, double isoval = 0.) const</code> <p>Contours a scalar function defined on the tet mesh, given by the input vector <code>phi</code>, according to the isovalue <code>isoval</code>. Returns pointers to the mesh and geometry objects defining the polygon mesh of the resulting isosurface.</p>"},{"location":"algorithm/solvers/#grid-solver","title":"Grid solver","text":"<code>std::array&lt;size_t, 3&gt; SignedHeatGridSolver::getGridResolution() const</code> <p>Returns a length-3 array giving the number of cells of the background grid along the x-, y-, and z-axes, respectively.</p> <code>std::tuple&lt;Eigen::Vector3d, Eigen::Vector3d&gt; SignedHeatGridSolver::getBBox() const</code> <p>Returns the tuple <code>{bboxMin, bboxMin}</code>, where <code>bboxMin</code> and <code>bboxMin</code> are the 3D positions of the minimal and maximal node corners of the grid, respectively.</p> <p>These two functions expose the order in which scalar data defined at grid nodes is flattened into a single 1D vector.</p> <code>size_t SignedHeatGridSolver::indicesToNodeIndex(const size_t&amp; i, const size_t&amp; j, const size_t&amp; k) const</code> <p>Converts a triple of indices indicating a node\u2019s position along the x-, y-, and z- axes, to a single index representing the corresponding global index of the node. </p> <code>Vector3 SignedHeatGridSolver::indicesToNodePosition(const size_t&amp; i, const size_t&amp; j, const size_t&amp; k) const</code> <p>Returns the global 3D position of a node given a triple of indices indicating the node\u2019s position along the x-, y-, and z- axes.</p>"},{"location":"build/building/","title":"Building","text":"<p><code>signed-heat-3d</code> uses CMake for to configure the build system. The basic workflow for downloading and compiling <code>signed-heat-3d</code> via a terminal is:</p> <p><pre><code>git clone --recurse-submodules https://github.com/nzfeng/signed-heat-3d.git\ncd signed-heat-3d\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j\n</code></pre> If you do not clone recursively, some submodules or sub-submodules will not clone. (In particular, you may get errors about missing <code>CMakeLists.txt</code> files.) Initialize/update these submodules by running <code>git submodule update --init --recursive</code> or <code>git submodule update --recursive</code>.</p> <p>The above commands compile <code>signed-heat-3d</code> as a library, and do not build any executables.</p> <p>You can add <code>signed-heat-3d</code> to an existing project\u2019s CMakeLists.txt using</p> <pre><code>add_subdirectory(\"path/to/signed-heat-3d\") # replace with your path\ntarget_link_libraries(your-project-target signed-heat-3d)\n</code></pre>"},{"location":"build/building/#example","title":"Example","text":"<p>The sample project demonstrates how to use <code>signed-heat-3d</code> within another project, using a build system and a GUI.</p>"},{"location":"build/building/#compile-options","title":"Compile options","text":"<p>Linear solves can be optionally accelerated using the algebraic multigrid library AMGCL, which requires Boost. If you do not want to use Boost, use <code>cmake -DSHM_NO_AMGCL=On</code> to compile to a program without AMGCL but with solve times \\~5x slower (more or less for larger/smaller problems). Force use of AMGCL via <code>cmake -DSHM_NO_AMGCL=Off</code>. Boost can be installed on macOS using <code>brew install boost</code>, and the necessary modules on Ubuntu using</p> <pre><code>sudo apt-get -y update\nsudo apt-get -y install libboost-dev libboost-test-dev libboost-program-options-dev libboost-serialization-dev\n</code></pre> <p>Windows users should probably follow the instructions on the Boost website.</p>"},{"location":"build/tests/","title":"Tests","text":""},{"location":"build/tests/#running-tests","title":"Running tests","text":"<p>All tests are stored in the <code>test/</code> subdirectory, which also contains a few small input files. We use GoogleTest as a testing framework.</p> <p>Compile and execute the tests using <pre><code>cd signed-heat-3d/test\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j\nbin/shm_test\n</code></pre></p>"}]}